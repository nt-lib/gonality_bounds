function DifferentialExpansion(omega, x, d)
/*
Given a differential omega on a curve, a place x on the same curve, and a precision d,
returns the Laurent series expansion of omega at x to precision d.
*/
    F := FunctionField(Curve(x));
    u := UniformizingParameter(x);
    du := Differential(u);
    Fx,mx := Completion(F, x : Precision := d);
    f := mx(omega/du);
    return f;
end function;

// intrinsic IntegerSolutions(ns::[RngIntElt], d::RngIntElt) -> SeqEnum[SeqEnum[RngIntElt]]
function IntegerSolutions(ns, d)
// {Returns all nonnegative integer vectors [i1, ..., ik] such that i1*ns[1] + ... + ik*ns[k] = d.}
    // require forall{n : n in ns | n gt 0} : "All entries in ns must be positive.";
    ns2 := Seqset(ns);
    // require #ns2 eq #ns : "Entries in ns must be distinct.";
    // require d ge 0 : "Target d must be nonnegative.";

    parts := RestrictedPartitions(d, ns2);
    return [ [Multiplicity(Multiset(P), n) : n in ns] : P in parts ];
end function;
//end intrinsic;

function DivisorsCandidatesByPartition(degree_counts, degree_partition)
/* The places up to degree d on C are assumed to be stored in a list of list as generated by the following code:

places := [Places(C, i) : i in [1..d]];

The degree_counts list stores how many places there are of each degree, i.e. `degree_counts := [#p : p in places];`

The degree_partition is a partition returned by IntegerSolutions(degree_counts, d) and tells how often we should include
a place of each degree when building the divisor.

A divisor is stored as a list of multisets, where the elements in the i-th multiset correspond to indices places[i]
For example the list of multisets: <{* 4^^2 *}, {* 10 *}, {* *}, {* *}> 
corresponds to the divisor 2*places[1][4] + places[2][10]
And the list of multisets:   <{* 7, 9 *}, {* 3 *}, {* *}, {* *}>,
corresponds to the divisor places[1][7] + places[1][9]  + places[2][3]
*/
    d := #degree_counts;
    assert d eq #degree_partition;
    return CartesianProduct([Multisets({1..degree_counts[i]}, degree_partition[i]) : i in [1..d]]);
end function;

function DivisorsCandidates(degree_counts, cache, filter : First := false)
/* Loop over all divisor candidates D and return those that satisfy filter(D) eq true.  See DivisorsCandidatesByPartition how divisors are
represented.
Cache can be anything and will be passed to the filter function. It can be used to make sure that the filter function has access to
precomputed data (like expansions of differentials at the different places).

If First is true (default = false) then only return the first divisor that satisfies the filter
*/
//todo optimize so that we only loop over degree_partitions so that degree_partitions[1] is at least #X(Fq) / (q+1)
    d := #degree_counts;
    divisors := [];
    for degree_partition in IntegerSolutions([1..d],d) do
        for D in DivisorsCandidatesByPartition(degree_counts, degree_partition) do
            if filter(D, cache) then
                if First then return [D]; end if;
                Append(~divisors, D);
            end if;
        end for;
    end for;
    return divisors;
end function;

function PrecomputePowerseriesExpansions(C, places, d)
    // The PowerseriesExpansions at all x in places
    // up to precision d/deg(x)
    /*
    Returns expansions, where expansions[i][j][k] stores the expansion of basis differential omega  at degree i place places[i][k]. 
    */
    expansions := [];
    Differentials := BasisOfHolomorphicDifferentials(C);
    for omega in Differentials do
        for i in [1..d] do
            degree_i_expansions := [];
            for x in places[i] do
                Append(~degree_i_expansion, DifferentialExpansion(omega, x, d div i));
            end for;
        end for;
        Append(~expansions, degree_i_expansions);
    return expansions;
end function;

function DifferentialVanishingMatrix(powerseries_expansions, D)
    // The matrix that describes the relations the diffrentials must satisfy to vansih at
    // the divisor D
    // powerseries_expansions: precomputed powerseries expansions at the different places
    // D: divisor in the format described in DivisorsCandidatesByPartition
end function;

function NumPoints(X, q)
    /*
    Given X / Fq returns #X(Fq) 
    //  #X(Fq) / (q+1)
    // see drews Magma at https://github.com/AndrewVSutherland/Magma/blob/main/gl2points.m
    // Is input X defined over Q or Fq?
    */    
end function;


/* Example usage

//IntegerSolutions
ns := [1, 2, 3, 4];
d := 4;
print IntegerSolutions(ns, d);


//DivisorsCandidatesByPartition
degree_counts := [ 4, 12, 8, 0 ];
degree_partition := [ 2, 1, 0, 0 ];
divs := DivisorsCandidatesByPartition(degree_counts, degree_partition);
print divs;

//DivisorsCandidates
degree_counts := [ 2, 2, 2, 0 ];
divs := DivisorsCandidates(degree_counts, [], func< D, cache | true>);
print divs;
print DivisorsCandidates(degree_counts, [], func< D, cache | true> : First := true);

//DifferentialExpansion
P<x,y,z> := ProjectiveSpace(GF(3), 2);
// https://beta.lmfdb.org/ModularCurve/Q/8.96.3.e.1/
f := 4*x^4 - y^4 - z^4;
C := Curve(P,f);
x := Places(C,2)[2];
omega := BasisOfHolomorphicDifferentials(C)[1];

DifferentialExpansion(omega, x, d);


//DifferentialVanishingMatrix
places := [Places(C, i) : i in [1..d]];
powerseries_expansions := PrecomputePowerseriesExpansions(C, places, d);
D := <{* 1, 2 *}, {* 1 *}, {* *}, {* *}>;
DifferentialVanishingMatrix(powerseries_expansions, D);


*/
