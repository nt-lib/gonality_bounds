function DifferentialExpansion(omega, x, d)
/*
Given a differential omega on a curve, a place x on the same curve, and a precision d,
returns the Laurent series expansion of omega at x to precision d.
*/
    F := FunctionField(Curve(x));
    u := UniformizingParameter(x);
    du := Differential(u);
    Fx,mx := Completion(F, x : Precision := d);
    f := mx(omega/du);
    return f;
end function;

function DifferentialExpansionVector(omega, x, d)
/*
Given a differential omega on a curve, a place x on the same curve, and a precision d,
returns the Laurent series expansion of omega at x to precision d.
*/
    f := DifferentialExpansion(omega, x, d);
    F := BaseRing(Curve(x));
    return [Eltseq(Coefficient(f,i),F) : i in [0..(d-1)]];
end function;

// intrinsic IntegerSolutions(ns::[RngIntElt], d::RngIntElt) -> SeqEnum[SeqEnum[RngIntElt]]
function IntegerSolutions(ns, d)
// {Returns all nonnegative integer vectors [i1, ..., ik] such that i1*ns[1] + ... + ik*ns[k] = d.}
    // require forall{n : n in ns | n gt 0} : "All entries in ns must be positive.";
    ns2 := Seqset(ns);
    // require #ns2 eq #ns : "Entries in ns must be distinct.";
    // require d ge 0 : "Target d must be nonnegative.";

    parts := RestrictedPartitions(d, ns2);
    return [ [Multiplicity(M, n) : n in ns] where M := Multiset(P) : P in parts ];
end function;
//end intrinsic;

function DivisorCandidatesByPartition(degree_counts, degree_partition, n)
/* The places up to degree d on C are assumed to be stored in a list of list as generated by the following code:

places := [Places(C, i) : i in [1..d]];

The degree_counts list stores how many places there are of each degree, i.e. `degree_counts := [#p : p in places];`

The degree_partition is a partition returned by IntegerSolutions(degree_counts, d) and tells how often we should include
a place of each degree when building the divisor.

A divisor is stored as a list of multisets, where the elements in the i-th multiset correspond to indices places[i]
For example the list of multisets: <{* 4^^2 *}, {* 10 *}, {* *}, {* *}> 
corresponds to the divisor 2*places[1][4] + places[2][10]
And the list of multisets:   <{* 7, 9 *}, {* 3 *}, {* *}, {* *}>,
corresponds to the divisor places[1][7] + places[1][9]  + places[2][3]

The integer n indicates how many places of degree 1 should be in D.
*/
    d := #degree_counts;
    //assert d eq #degree_partition;
    assert degree_partition[1] ge n;
    if n le 1 then
        return CartesianProduct([Multisets({1..degree_counts[i]}, degree_partition[i]) : i in [1..d]]);
    end if;
    
    S1 := [S : S in Multisets({1..degree_counts[1]}, degree_partition[1]) | #Set(S) ge n];
    return CartesianProduct(S1 cat [Multisets({1..degree_counts[i]}, degree_partition[i]) : i in [2..d]]);
end function;

function DivisorCandidates(degree_counts, n, cache, filter : First := false)
/* Loop over all divisor candidates D and return those that satisfy filter(D) eq true.  See DivisorCandidatesByPartition how divisors are
represented.
Cache can be anything and will be passed to the filter function. It can be used to make sure that the filter function has access to
precomputed data (like expansions of differentials at the different places).

If First is true (default = false) then only return the first divisor that satisfies the filter

The integer n indicates how many places of degree 1 should be in D.
*/
//todo optimize so that we only loop over degree_partitions so that degree_partitions[1] is at least #X(Fq) / (q+1)
    d := #degree_counts;
    divisors := [];
    for degree_partition0 in IntegerSolutions([1..Max(d-n,1)],d-n) do
        degree_partition := degree_partition0;
        degree_partition[1] := degree_partition[1] + n;
        for D in DivisorCandidatesByPartition(degree_counts, degree_partition, n) do
            if filter(D, cache) then
                if First then return [D]; end if;
                Append(~divisors, D);
            end if;
        end for;
    end for;
    return divisors;
end function;

function PrecomputePowerseriesExpansions(C, places, d)
    // The PowerseriesExpansions at all x in places
    // up to precision d/deg(x)
    /*
    Returns expansions, where expansions[i][j][k] stores the expansion of basis differential omega_i at degree j place places[j][k]. 
    */
    expansions := [];
    Differentials := BasisOfHolomorphicDifferentials(C);
    for omega in Differentials do
        omega_expansions := [];
        for j in [1..#places] do
            degree_j_expansions := [];
            for x in places[j] do
                Append(~degree_j_expansions, DifferentialExpansionVector(omega, x, d div j));
            end for;
            Append(~omega_expansions, degree_j_expansions);
        end for;
        Append(~expansions, omega_expansions);
    end for;
    return expansions;
end function;

function DifferentialVanishingVector(expansions, D)
    // The vector corresponding to the row of one differential omega in the
    // DifferentialVanishingMatrix 
    d := #D;
    row := [];
    for j in [1..d] do
        // sorting is important since we want the output to be the same independent
        // of how the points in the multiset of D are stored internally.
        support := Sort(Setseq(Set(D[j])));
        row cat:= [expansions[j][k][1..Multiplicity(D[j], k)] : k in support];
    end for;
    return Vector(&cat &cat row);
end function;

function DifferentialVanishingMatrix(powerseries_expansions, D)
    // The matrix that describes the relations the diffrentials must satisfy to vanish at
    // the divisor D
    // powerseries_expansions: precomputed powerseries expansions at the different places
    // D: divisor in the format described in DivisorCandidatesByPartition
    return Matrix([DifferentialVanishingVector(expansion, D) : expansion in powerseries_expansions]);
end function;

function HasNonconstantFunction(D, powerseries_expansions)
    // Riemann Roch states h^0(D) - h^0(Omega(-D)) = deg D + 1 - g
    // so h^0(D) >= 2 if and only if h^0(Omega(-D)) + deg D + 1 - g >= 2
    // meaning h^0(Omega(-D)) >= g-deg D -1
    // The vanishing matrix is a g by deg D matrix whose kernel is h^0(Omega(-D))
    // so the condition is that the vanishing matrix should have rank < deg D
    M := DifferentialVanishingMatrix(powerseries_expansions, D);
    d := NumberOfColumns(M);
    r := Rank(DifferentialVanishingMatrix(powerseries_expansions, D));
    //print r,d,D;
    return r lt d;
end function;

function HasFunctionOfDegreeAtMost(C, d)
    n := Ceiling(#Places(C, 1)/(#BaseRing(C)+1));
    if n gt d then return false; end if;
    n1 := Min(n,d-1);
    places := [Places(C, i) : i in [1..(d-n1)]] cat [[] : i in [1..n1]];
    degree_counts := [#p : p in places];
    powerseries_expansions := PrecomputePowerseriesExpansions(C, places, d);
    g_d_1s := DivisorCandidates(degree_counts, n, powerseries_expansions, HasNonconstantFunction : First := true);
    return #g_d_1s ge 1;
end function;

function Gonality(C)
    d := 1;
    while not HasFunctionOfDegreeAtMost(C, d) do
        d +:=1;
        print "doing degree: ", d;
    end while;
    return d;
end function;

function NumPoints(X, q)
    /*
    Given X / Fq returns #X(Fq) 
    //  #X(Fq) / (q+1)
    // see drews Magma at https://github.com/AndrewVSutherland/Magma/blob/main/gl2points.m
    // Is input X defined over Q or Fq?
    */    
end function;


/* Example usage

//IntegerSolutions
ns := [1, 2, 3, 4];
d := 4;
print IntegerSolutions(ns, d);


//DivisorCandidatesByPartition
degree_counts := [ 4, 12, 8, 0 ];
degree_partition := [ 2, 1, 0, 0 ];
divs := DivisorCandidatesByPartition(degree_counts, degree_partition);
print divs;

//DivisorCandidates
degree_counts := [ 2, 2, 2, 0 ];
divs := DivisorCandidates(degree_counts, [], func< D, cache | true>);
print divs;
print DivisorCandidates(degree_counts, [], func< D, cache | true> : First := true);

//DifferentialExpansion
d := 4;
P<x,y,z> := ProjectiveSpace(GF(3), 2);
// https://beta.lmfdb.org/ModularCurve/Q/8.96.3.e.1/
f := 4*x^4 - y^4 - z^4;
C := Curve(P,f);
x := Places(C,2)[2];
omega := BasisOfHolomorphicDifferentials(C)[1];

f := DifferentialExpansion(omega, x, d);
print f;

//DifferentialExpansionVector
f := DifferentialExpansionVector(omega, x, d);
print f;

//PrecomputePowerseriesExpansions
places := [Places(C, i) : i in [1..d]];
powerseries_expansions := PrecomputePowerseriesExpansions(C, places, d);
print powerseries_expansions;

//DifferentialVanishingVector
D := <{* 1, 2 *}, {* 1 *}, {* *}, {* *}>;
DifferentialVanishingVector(powerseries_expansions[1], D);

//DifferentialVanishingMatrix
DifferentialVanishingMatrix(powerseries_expansions, D);

//HasFunctionOfDegreeAtMost
P<x,y,z> := ProjectiveSpace(GF(3), 2);
// https://beta.lmfdb.org/ModularCurve/Q/8.96.3.e.1/
f := 4*x^4 - y^4 - z^4;
C := Curve(P,f);
// this curve has gonality 3 over F_3
HasFunctionOfDegreeAtMost(C, 2),HasFunctionOfDegreeAtMost(C, 3);

P<x,y,z> := ProjectiveSpace(GF(5), 2);
// https://beta.lmfdb.org/ModularCurve/Q/8.96.3.e.1/
f := 4*x^4 - y^4 - z^4;
C := Curve(P,f);
// but gonality 4 over F_5
HasFunctionOfDegreeAtMost(C, 3),HasFunctionOfDegreeAtMost(C, 4);


//Gonality
Gonality(C);

*/
