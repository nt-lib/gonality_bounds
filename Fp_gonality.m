function UniformisingDifferential(omegas, x)
/*
Given a sequence omegas of differentials on a function field and a place x on the same function field,
returns a differential of omegas with valuation 0 at x.
*/
    for omega in omegas do
        if Valuation(omega,x) eq 0 then
            return omega;
        end if;
    end for;
    error "No differential with valuation zero";
end function;

function DifferentialExpansionMatrices(omegas, x, d)
/*
Given a sequence omegas of differentials on a function field, a place x on the same function field,
and a precision d, returns a sequence of d matrices, the ith of which encodes the ith coefficient of
the Laurent series expansion of each differential of omegas at x.
*/
    F := FunctionField(x);
    CF := ConstantField(F);
    du := UniformisingDifferential(omegas, x);
    
    fs := [omega/du : omega in omegas];
    
    if d eq 1 then
        m := Matrix([Eltseq(Evaluate(f, x), CF) : f in fs]);
        return [m];
    else
        Fx, mx := Completion(F, x : Precision := d);
        expansions := [mx(f) : f in fs];
        ms := [Matrix([Eltseq(Coefficient(e, i), CF) : e in expansions]) : i in [0..(d-1)]];
        return ms;
    end if;
end function;

function IntegerSolutions(ns, d)
/*
Returns all nonnegative integer vectors [i1, ..., ik] such that i1*ns[1] + ... + ik*ns[k] = d
*/
    ns2 := Seqset(ns);
    parts := RestrictedPartitions(d, ns2);
    return [ [Multiplicity(M, n) : n in ns] where M := Multiset(P) : P in parts ];
end function;

function DivisorCandidatesByPartition(degree_counts, degree_partition, n)
/* The places up to degree d on FF are assumed to be stored in a list of list as generated by the following code:

places := [Places(FF, i) : i in [1..d]];

The degree_counts list stores how many places there are of each degree, i.e. `degree_counts := [#p : p in places];`

The degree_partition is a partition returned by IntegerSolutions(degree_counts, d) and tells how often we should include
a place of each degree when building the divisor.

A divisor is stored as a list of multisets, where the elements in the i-th multiset correspond to indices places[i]
For example the list of multisets: <{* 4^^2 *}, {* 10 *}, {* *}, {* *}> 
corresponds to the divisor 2*places[1][4] + places[2][10]
And the list of multisets:   <{* 7, 9 *}, {* 3 *}, {* *}, {* *}>,
corresponds to the divisor places[1][7] + places[1][9]  + places[2][3]

The integer n indicates how many places of degree 1 should be in D.
*/
    d := #degree_partition;
    assert degree_partition[1] ge n;
    if n le 1 then
        return CartesianProduct([Multisets({1..degree_counts[i]}, degree_partition[i]) : i in [1..d]]);
    end if;
    
    S1 := {S : S in Multisets({1..degree_counts[1]}, degree_partition[1]) | #Set(S) ge n};
    return CartesianProduct([S1] cat [Multisets({1..degree_counts[i]}, degree_partition[i]) : i in [2..d]]);
end function;

function DivisorCandidates(degree_counts, n, cache, filter : First := false)
/* Loop over all divisors D of degree equal to #degree_counts and return those that satisfy filter(D) eq true.  See DivisorCandidatesByPartition how divisors are
represented.
Cache can be anything and will be passed to the filter function. It can be used to make sure that the filter function has access to
precomputed data (like expansions of differentials at the different places).

If First is true (default = false) then only return the first divisor that satisfies the filter

The integer n gives a lower bound on how many places of degree 1 should be in the divisor D. So setting n=0 causes the code 
to loop over all divisors D of degree equal to #degree_counts.
*/
    d := #degree_counts;
    divisors := [];
    for degree_partition0 in IntegerSolutions([1..Max(d-n,1)],d-n) do
        degree_partition := degree_partition0;
        degree_partition[1] := degree_partition[1] + n;
        vprint Gonality: "Testing divisors of shape", degree_partition;
        for D in DivisorCandidatesByPartition(degree_counts, degree_partition, n) do
            if filter(D, cache) then
                if First then return [D]; end if;
                Append(~divisors, D);
            end if;
        end for;
    end for;
    return divisors;
end function;

function PrecomputePowerseriesExpansions(FF, places, d)
    // The PowerseriesExpansions at all x in places
    // up to precision d/deg(x)
    /*
    Returns expansions, where expansions[i][j][k] stores the (k-1)th coordinate of the expansion of
    the basis differentials of FF at degree i place places[i][j]. 
    */
    expansions := <>;
    differentials := BasisOfHolomorphicDifferentials(FF);
    for i in [1..#places] do
        degree_i_expansions := [];
        for x in places[i] do
            Append(~degree_i_expansions, DifferentialExpansionMatrices(differentials, x, d div i));
        end for;
        Append(~expansions, degree_i_expansions);
    end for;
    return expansions;
end function;

function DifferentialVanishingMatrix(expansions, D)
    // The matrix that describes the relations the differentials must satisfy to vanish at
    // the divisor D
    // expansions: precomputed powerseries expansions at the different places
    // D: divisor in the format described in DivisorCandidatesByPartition
    return HorizontalJoin(<expansions[i][j][k] : k in [1..n], j -> n in x, i -> x in D>);
end function;

function HasNonconstantFunction(D, powerseries_expansions)
    // Riemann Roch states h^0(D) - h^0(Omega(-D)) = deg D + 1 - g
    // so h^0(D) >= 2 if and only if h^0(Omega(-D)) + deg D + 1 - g >= 2
    // meaning h^0(Omega(-D)) >= g-deg D -1
    // The vanishing matrix is a g by deg D matrix whose kernel is h^0(Omega(-D))
    // so the condition is that the vanishing matrix should have rank < deg D
    M := DifferentialVanishingMatrix(powerseries_expansions, D);
    d := NumberOfColumns(M);
    r := Rank(M);
    return r lt d;
end function;

declare verbose Gonality, 1;

intrinsic HasFunctionOfDegreeAtMost(FF::FldFun, d::RngIntElt) -> BoolElt
{ Returns whether there is a function on FF with degree at most d. }
    if d gt Genus(FF) then
        vprint Gonality: "HasFunctionOfDegreeAtMost timing data", [0,0,0,0];
        return true;
    end if;
    
    t0 := Realtime();
    n := Ceiling(#Places(FF, 1)/(#ConstantField(FF)+1));
    t1 := Realtime();

    if n gt d then
        vprint Gonality: "HasFunctionOfDegreeAtMost timing data", [t1-t0,0,0,0];
        return false;
    end if;

    n1 := Min(n,d-1);
    vprint Gonality: "Computing places of degree at most", d-n1;
    places := [Places(FF, i) : i in [1..(d-n1)]] cat [[] : i in [1..n1]];
    t2 := Realtime();

    degree_counts := [#p : p in places];
    vprint Gonality: "Precomputing power series expansions";
    powerseries_expansions := PrecomputePowerseriesExpansions(FF, places, d);
    t3 := Realtime();

    g_d_1s := DivisorCandidates(degree_counts, n, powerseries_expansions, HasNonconstantFunction : First := true);
    t4 := Realtime();

    vprint Gonality: "HasFunctionOfDegreeAtMost timing data", [t1-t0,t2-t1,t3-t2,t4-t3];
    return #g_d_1s ge 1;
end intrinsic;

intrinsic Gonality(FF::FldFun : Bound := -1) -> RngIntElt
{ Computes the gonality of the function field FF. The Bound parameter is a parameter specifying
up to which degree to look for functions.

If the optional parameter Bound is not provided then it will return the gonality. 
If the parameter Bound is a positive integer then the return value d will always be
at most Bound + 1; And the meaning of d is as follows:
If d <= Bound then d equals the gonality of FF;
If d = Bound + 1 then d is a lowerbound for the gonality of FF. }
    d := 1;
    while d ne Bound+1 do
        vprint Gonality: "Trying degree", d;
        if HasFunctionOfDegreeAtMost(FF, d) then
            break;
        end if;
        d +:= 1;
    end while;
    return d;
end intrinsic;

intrinsic HasFunctionOfDegreeAtMost(C::Crv[FldFin], d::RngIntElt) -> BoolElt
{ Returns whether there is a function on C with degree at most d. }
    FF := AlgorithmicFunctionField(FunctionField(C));
    return HasFunctionOfDegreeAtMost(FF, d);
end intrinsic;

intrinsic Gonality(C::Crv[FldFin] : Bound := -1) -> RngIntElt
{ Computes the gonality of the curve C. The Bound parameter is a parameter specifying
up to which degree to look for functions.

If the optional parameter Bound is not provided then it will return the gonality. 
If the parameter Bound is a positive integer then the return value d will always be
at most Bound + 1; And the meaning of d is as follows:
If d <= Bound then d equals the gonality of FF;
If d = Bound + 1 then d is a lowerbound for the gonality of FF. }
    FF := AlgorithmicFunctionField(FunctionField(C));
    return Gonality(FF : Bound := Bound);
end intrinsic;

/* Example usage

//IntegerSolutions
ns := [1, 2, 3, 4];
d := 4;
print IntegerSolutions(ns, d);

//DivisorCandidatesByPartition
degree_counts := [ 4, 12, 8, 0 ];
degree_partition := [ 2, 1, 0, 0 ];
divs := DivisorCandidatesByPartition(degree_counts, degree_partition);
print divs;

//DivisorCandidates
degree_counts := [ 2, 2, 2, 0 ];
divs := DivisorCandidates(degree_counts, [], func< D, cache | true>);
print divs;
print DivisorCandidates(degree_counts, [], func< D, cache | true> : First := true);

//DifferentialExpansionMatrices
d := 4;
P<x,y,z> := ProjectiveSpace(GF(3), 2);
// https://beta.lmfdb.org/ModularCurve/Q/8.96.3.e.1/
f := 4*x^4 - y^4 - z^4;
C := Curve(P,f);
FF := AlgorithmicFunctionField(FunctionField(C));
x := Places(FF,2)[2];
differentials := BasisOfHolomorphicDifferentials(FF);

f := DifferentialExpansionMatrices(differentials, x, d);
print f;

//PrecomputePowerseriesExpansions
places := [Places(FF, i) : i in [1..d]];
powerseries_expansions := PrecomputePowerseriesExpansions(FF, places, d);
print powerseries_expansions;

//DifferentialVanishingMatrix
DifferentialVanishingMatrix(powerseries_expansions, D);

//HasFunctionOfDegreeAtMost
P<x,y,z> := ProjectiveSpace(GF(3), 2);
// https://beta.lmfdb.org/ModularCurve/Q/8.96.3.e.1/
f := 4*x^4 - y^4 - z^4;
C := Curve(P,f);
// this curve has gonality 3 over F_3
HasFunctionOfDegreeAtMost(C, 2), HasFunctionOfDegreeAtMost(C, 3);

P<x,y,z> := ProjectiveSpace(GF(5), 2);
// https://beta.lmfdb.org/ModularCurve/Q/8.96.3.e.1/
f := 4*x^4 - y^4 - z^4;
C := Curve(P,f);
// but gonality 4 over F_5
HasFunctionOfDegreeAtMost(C, 3), HasFunctionOfDegreeAtMost(C, 4);

//Gonality
Gonality(C);
SetVerbose("Gonality", 1);
Gonality(C : Bound:=3);

*/
