function UniformisingDifferential(omegas, x)
    for omega in omegas do
        if Valuation(omega,x) eq 0 then
            return omega;
        end if;
    end for;
end function;

function DifferentialExpansionMatrices(omegas, x, d)
/*
Given a sequence omegas of differentials on a function field, a place x on the same function field,
and a precision d, returns a sequence of d matrices, the ith of which encodes the ith coefficient of
the Laurent series expansion of each differential of omegas at x.
*/
    F := FunctionField(x);
    BF := ConstantField(F);
    //u := UniformizingParameter(x);
    //du := Differential(u);
    du := UniformisingDifferential(omegas, x);
    
    fs := [omega/du : omega in omegas];
    
    if d eq 1 then
        m := Matrix([Eltseq(Evaluate(f, x), BF) : f in fs]);
        assert Ncols(m) eq Degree(x);
        return [m];
    else
        Fx, mx := Completion(F, x : Precision := d);
        expansions := [mx(f) : f in fs];
        ms := [Matrix([Eltseq(Coefficient(e, i), BF) : e in expansions]) : i in [0..(d-1)]];
        assert forall{m : m in ms | Ncols(m) eq Degree(x)};
        return ms;
    end if;
end function;

// intrinsic IntegerSolutions(ns::[RngIntElt], d::RngIntElt) -> SeqEnum[SeqEnum[RngIntElt]]
function IntegerSolutions(ns, d)
// {Returns all nonnegative integer vectors [i1, ..., ik] such that i1*ns[1] + ... + ik*ns[k] = d.}
    // require forall{n : n in ns | n gt 0} : "All entries in ns must be positive.";
    ns2 := Seqset(ns);
    // require #ns2 eq #ns : "Entries in ns must be distinct.";
    // require d ge 0 : "Target d must be nonnegative.";

    parts := RestrictedPartitions(d, ns2);
    return [ [Multiplicity(M, n) : n in ns] where M := Multiset(P) : P in parts ];
end function;
//end intrinsic;

function DivisorCandidatesByPartition(degree_counts, degree_partition, n)
/* The places up to degree d on FF are assumed to be stored in a list of list as generated by the following code:

places := [Places(FF, i) : i in [1..d]];

The degree_counts list stores how many places there are of each degree, i.e. `degree_counts := [#p : p in places];`

The degree_partition is a partition returned by IntegerSolutions(degree_counts, d) and tells how often we should include
a place of each degree when building the divisor.

A divisor is stored as a list of multisets, where the elements in the i-th multiset correspond to indices places[i]
For example the list of multisets: <{* 4^^2 *}, {* 10 *}, {* *}, {* *}> 
corresponds to the divisor 2*places[1][4] + places[2][10]
And the list of multisets:   <{* 7, 9 *}, {* 3 *}, {* *}, {* *}>,
corresponds to the divisor places[1][7] + places[1][9]  + places[2][3]

The integer n indicates how many places of degree 1 should be in D.
*/
    d := #degree_partition;
    //assert d eq #degree_partition;
    assert degree_partition[1] ge n;
    if n le 1 then
        return CartesianProduct([Multisets({1..degree_counts[i]}, degree_partition[i]) : i in [1..d]]);
    end if;
    
    S1 := {S : S in Multisets({1..degree_counts[1]}, degree_partition[1]) | #Set(S) ge n};
    return CartesianProduct([S1] cat [Multisets({1..degree_counts[i]}, degree_partition[i]) : i in [2..d]]);
end function;

function DivisorCandidates(degree_counts, n, cache, filter : First := false)
/* Loop over all divisor candidates D and return those that satisfy filter(D) eq true.  See DivisorCandidatesByPartition how divisors are
represented.
Cache can be anything and will be passed to the filter function. It can be used to make sure that the filter function has access to
precomputed data (like expansions of differentials at the different places).

If First is true (default = false) then only return the first divisor that satisfies the filter

The integer n indicates how many places of degree 1 should be in D.
*/
//todo optimize so that we only loop over degree_partitions so that degree_partitions[1] is at least #X(Fq) / (q+1)
    d := #degree_counts;
    divisors := [];
    for degree_partition0 in IntegerSolutions([1..Max(d-n,1)],d-n) do
        degree_partition := degree_partition0;
        degree_partition[1] := degree_partition[1] + n;
        for D in DivisorCandidatesByPartition(degree_counts, degree_partition, n) do
            if filter(D, cache) then
                if First then return [D]; end if;
                Append(~divisors, D);
            end if;
        end for;
    end for;
    return divisors;
end function;

function PrecomputePowerseriesExpansions(FF, places, d)
    // The PowerseriesExpansions at all x in places
    // up to precision d/deg(x)
    /*
    Returns expansions, where expansions[i][j][k] stores the (k-1)th coordinate of the expansion of
    the basis differentials of FF at degree i place places[i][j]. 
    */
    expansions := <>;
    differentials := BasisOfHolomorphicDifferentials(FF);
    for i in [1..#places] do
        degree_i_expansions := [];
        for x in places[i] do
            Append(~degree_i_expansions, DifferentialExpansionMatrices(differentials, x, d div i));
        end for;
        Append(~expansions, degree_i_expansions);
    end for;
    return expansions;
end function;

function DifferentialVanishingMatrix(expansions, D)
    // The matrix that describes the relations the differentials must satisfy to vanish at
    // the divisor D
    // expansions: precomputed powerseries expansions at the different places
    // D: divisor in the format described in DivisorCandidatesByPartition
    return HorizontalJoin(<expansions[i][j][k] : k in [1..n], j -> n in x, i -> x in D>);
end function;

function HasNonconstantFunction(D, powerseries_expansions)
    // Riemann Roch states h^0(D) - h^0(Omega(-D)) = deg D + 1 - g
    // so h^0(D) >= 2 if and only if h^0(Omega(-D)) + deg D + 1 - g >= 2
    // meaning h^0(Omega(-D)) >= g-deg D -1
    // The vanishing matrix is a g by deg D matrix whose kernel is h^0(Omega(-D))
    // so the condition is that the vanishing matrix should have rank < deg D
    M := DifferentialVanishingMatrix(powerseries_expansions, D);
    d := NumberOfColumns(M);
    r := Rank(M);
    //print r,d,D;
    return r lt d;
end function;

function HasFunctionOfDegreeAtMost(FF, d : TimingData := false)
    t0 := Realtime();
    n := Ceiling(#Places(FF, 1)/(#ConstantField(FF)+1));
    t1 := Realtime(); //print "Time for computing n:", t1 - t0;

    if n gt d then 
        if TimingData then
            return false, [t1-t0,0,0,0];
        else
            return false;
        end if;
    end if;

    n1 := Min(n,d-1);
    places := [Places(FF, i) : i in [1..(d-n1)]] cat [[] : i in [1..n1]];
    t2 := Realtime(); //print "Time for computing places:", t2 - t1;

    degree_counts := [#p : p in places];
    powerseries_expansions := PrecomputePowerseriesExpansions(FF, places, d);
    t3 := Realtime(); //print "Time for PrecomputePowerseriesExpansions:", t3 - t2;

    g_d_1s := DivisorCandidates(degree_counts, n, powerseries_expansions, HasNonconstantFunction : First := true);
    t4 := Realtime(); //print "Time for DivisorCandidates:", t4 - t3;

    result := #g_d_1s ge 1;
    if TimingData then return result,[t1-t0,t2-t1,t3-t2,t4-t3]; end if;
    return result;
end function;


function Gonality(FF : Bound := -1, TimingData := false)
/* Computes the gonality of the function field FF. The Bound parameter is a parameter specifying
up to which degree to look for functions.

If the optional parameter Bound is not provided then it will return the gonality. 
If the parameter Bound is a positive integer then the return value d will always be
at most Bound + 1; And the meaning of d is as follows:
If d <= Bound then d equals the gonality of FF;
If d = Bound + 1 then d is a lowerbound for the gonality of FF.
*/
    d := 0;
    has_function := false;
    timing_data := [];
    while not has_function do
        d +:=1;
        if d eq Bound+1 then
            // break early
            has_function := true;
        else   
            print "doing degree: ", d;
            if TimingData then
                has_function, timings := HasFunctionOfDegreeAtMost(FF, d: TimingData := TimingData);
                Append(~timing_data, timings);
            else
                has_function := HasFunctionOfDegreeAtMost(FF, d: TimingData := TimingData);
            end if;
        end if;
    end while;
    if TimingData then return d, timing_data; end if;
    return d;
end function;


/* Example usage

//IntegerSolutions
ns := [1, 2, 3, 4];
d := 4;
print IntegerSolutions(ns, d);


//DivisorCandidatesByPartition
degree_counts := [ 4, 12, 8, 0 ];
degree_partition := [ 2, 1, 0, 0 ];
divs := DivisorCandidatesByPartition(degree_counts, degree_partition);
print divs;

//DivisorCandidates
degree_counts := [ 2, 2, 2, 0 ];
divs := DivisorCandidates(degree_counts, [], func< D, cache | true>);
print divs;
print DivisorCandidates(degree_counts, [], func< D, cache | true> : First := true);

//DifferentialExpansionMatrices
d := 4;
P<x,y,z> := ProjectiveSpace(GF(3), 2);
// https://beta.lmfdb.org/ModularCurve/Q/8.96.3.e.1/
f := 4*x^4 - y^4 - z^4;
C := Curve(P,f);
FF := AlgorithmicFunctionField(FunctionField(C));
x := Places(FF,2)[2];
differentials := BasisOfHolomorphicDifferentials(FF);

f := DifferentialExpansionMatrices(differentials, x, d);
print f;

//PrecomputePowerseriesExpansions
places := [Places(FF, i) : i in [1..d]];
powerseries_expansions := PrecomputePowerseriesExpansions(FF, places, d);
print powerseries_expansions;

//DifferentialVanishingMatrix
DifferentialVanishingMatrix(powerseries_expansions, D);

//HasFunctionOfDegreeAtMost
P<x,y,z> := ProjectiveSpace(GF(3), 2);
// https://beta.lmfdb.org/ModularCurve/Q/8.96.3.e.1/
f := 4*x^4 - y^4 - z^4;
C := Curve(P,f);
FF := AlgorithmicFunctionField(FunctionField(C));
// this curve has gonality 3 over F_3
HasFunctionOfDegreeAtMost(FF, 2),HasFunctionOfDegreeAtMost(FF, 3);

P<x,y,z> := ProjectiveSpace(GF(5), 2);
// https://beta.lmfdb.org/ModularCurve/Q/8.96.3.e.1/
f := 4*x^4 - y^4 - z^4;
C := Curve(P,f);
FF := AlgorithmicFunctionField(FunctionField(C));
// but gonality 4 over F_5
HasFunctionOfDegreeAtMost(FF, 3),HasFunctionOfDegreeAtMost(FF, 4);


//Gonality
Gonality(FF);
Gonality(FF : Bound:=3, TimingData:=true);

*/
